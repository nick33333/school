// Filename: stackrecursion.cpp
//
// The file basically contains two functions that generate all subsequences of an input string. One function is the (standard) recursive method,
// while the other is non-recursive and uses a stack. Both these functions have an identical output, and create a (linked) list of strings as their output.
//
// The code uses the List data structure used in a number of CSE101 assignments and tests.
//
// USAGE:  (the executable is generated by a Makefile)
//     ./stackrecursion <INPUT FILE> <OUTPUT FILE>
//
//     Only the first line of <INPUT FILE> is read, as a string. <OUTPUT FILE> contains all subsequences, each in a separate line.
//
//
// C. Seshadhri, Jan 2020, Oct 2020

#include <iostream>
#include "list.h"
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector>
#include <algorithm>
#include <sstream>
using namespace std;

// This class keeps pairs of string. This is useful for simulating the recursion through as stack.
class Pair
{
public:
    string in_str;
    string fixed_str;
};

// This function generates all subsequences of the input input_str, and outputs them as a list. This function does not use recursion.
// Input: string input_str
// Output: list of all subsequences of input_str
//

List allSubSeqStack(string input_str)
{
    List final_output;            // generate empty list
    stack<class Pair> recurStack; // empty stack that performs the recursion
    Pair init, stacktop;          // create a pair to push, to start the stac
    init.in_str = input_str;      // put the initial string
    init.fixed_str = "";          // this is the fixed string, initially empty
    recurStack.push(init);        // push this pair onto the top

    while (!recurStack.empty()) // while the stack is non-empty
    {
        stacktop = recurStack.top();       // get the top pair in stack
        recurStack.pop();                  // remove the top element of stack
        if (stacktop.in_str.length() == 0) // input string is empty, so this is base case
        {
            final_output.insert(stacktop.fixed_str); // insert the fixed string onto list
            continue;                                // pop the next element of stack
        }
        char last = stacktop.in_str.back(); // get last element of in_str
        stacktop.in_str.pop_back();         // remove last element of stack
        Pair to_push;                       // setting up elements to push onto stack
        to_push.in_str = stacktop.in_str;
        to_push.fixed_str = stacktop.fixed_str;
        recurStack.push(to_push);                      // this is for one recursive call
        to_push.fixed_str = last + stacktop.fixed_str; // this is for next recursive call
        recurStack.push(to_push);
    }
    return final_output;
}

List language(string input, int k) // Fuck my life, i get it right after the test
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    init.in_str = input; // abc
    init.fixed_str = "";
    recurStack.push(init);
    while (!recurStack.empty())
    {
        stacktop = recurStack.top();
        recurStack.pop();
        final_output.insert(stacktop.fixed_str);

        Pair to_push;
        for (int i = 0; i < input.length(); i++) // cycle through possible chars// each iter of a for loop seems to be propto n-1 of the ways that recursion trees split
        {
            to_push.in_str = input;
            to_push.fixed_str = stacktop.fixed_str + input[i]; // Build fixed_str by 1 char for each iteration

            if (to_push.fixed_str.length() == k) // If we built fixed_str up to size k, add entry into list
            {
                final_output.insert(to_push.fixed_str);
                to_push.fixed_str = stacktop.fixed_str;
                continue;
            }
            recurStack.push(to_push); // Since to_push's fixed_str isn't at capacity, push it to propogate more combos
            to_push.fixed_str = stacktop.fixed_str;
        } // exhausted possible chars
    }
    return final_output;
}

string mult(char s, int k)
{

    string out = "";
    for (int i = 0; i < k; i++)
    {
        out += s;
    }
    return out;
}

// WORKS?
List stretchStack(string input_str, int k)
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    init.in_str = input_str;
    init.fixed_str = "";
    recurStack.push(init);
    while (!recurStack.empty())
    {
        stacktop = recurStack.top();
        recurStack.pop();

        if (stacktop.in_str.length() == 0)
        {
            string ready = stacktop.fixed_str + stacktop.in_str; // might be useless
            // cout<<"[Inserting ready]: "<<ready<<endl;
            final_output.insert(ready);
            continue;
        }
        Pair to_push;
        string curr_in = stacktop.in_str;     // This use of the fixed_str of the stacktop Pair, we don't need to keep track of the index to swap with for in_str, hence the value of R // abc
        string curr_fix = stacktop.fixed_str; // ""
        for (int i = 0; i <= k - 1; i++)
        {
            char last = curr_in.back();              // last: c
            curr_in.pop_back();                      // curr_in: ab
            curr_fix = mult(last, i + 1) + curr_fix; // curr_fix: c

            to_push.in_str = curr_in;     // tp_in: ab
            to_push.fixed_str = curr_fix; // tp_fix: c
            recurStack.push(to_push);     // PUSH
                                          //             cout<<"in_str is: "<< curr_in<<endl;
                                          //             cout<<"Also: "<<first + curr_fix<<endl;
            curr_fix.erase(0, i + 1);     // curr_fix: _
            // cout<<"fixed_str is: "<< to_push.fixed_str<<endl<<endl;
            curr_in = curr_in + last; // abc
        }
    }
    return final_output;
}

// WORKS??
List bubblingStack(string input_str)
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    init.in_str = input_str;
    init.fixed_str = "";
    recurStack.push(init);
    while (!recurStack.empty())
    {
        stacktop = recurStack.top();
        recurStack.pop();

        if (stacktop.in_str.length() == 1)
        {
            string ready = stacktop.fixed_str + stacktop.in_str; // might be useless
            final_output.insert(ready);
            continue;
        }
        Pair to_push_n, to_push_y;
        string curr_in = stacktop.in_str; // This use of the fixed_str of the stacktop Pair, we don't need to keep track of the index to swap with for in_str, hence the value of R
        string curr_fix = stacktop.fixed_str;
        // first push (not swapped)
        char first = curr_in[0];                // a
        curr_in.erase(0, 1);                    // bc
        to_push_n.in_str = curr_in;             // bc
        to_push_n.fixed_str = curr_fix + first; // a
        curr_in = first + curr_in;              // abc
        recurStack.push(to_push_n);             // in: bc fix: a
        // second push (swapped)
        swap(curr_in[0], curr_in[1]);   // Swaps can always count on beginning -> bac
        first = curr_in[0];             // b
        curr_in.erase(0, 1);            // ac
        to_push_y.in_str = curr_in;     // ac
        curr_fix = curr_fix + first;    // b
        to_push_y.fixed_str = curr_fix; // b
        curr_in = first + curr_in;      // bac
        curr_fix.erase(0, 1);           //
        swap(curr_in[0], curr_in[1]);   // abc
        recurStack.push(to_push_y);
    }
    return final_output;
}

// WORKS?
List allAnagramsStack(string input_str)
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    init.in_str = input_str;
    init.fixed_str = "";
    recurStack.push(init);
    while (!recurStack.empty())
    {
        stacktop = recurStack.top();
        int R = stacktop.in_str.length() - 1;
        //         cout<<"LENGTH - 1 is: "<< R<<endl;
        //         cout<<"IN_STR is: "<< stacktop.in_str<<"FIXED_STR is: "<< stacktop.fixed_str<<endl;
        recurStack.pop();

        if (stacktop.in_str.length() == 0)
        {
            string ready = stacktop.fixed_str + stacktop.in_str; // might be useless
            // cout<<"[Inserting ready]: "<<ready<<endl;
            final_output.insert(ready);
            continue;
        }
        Pair to_push;
        string curr_in = stacktop.in_str; // This use of the fixed_str of the stacktop Pair, we don't need to keep track of the index to swap with for in_str, hence the value of R
        string curr_fix = stacktop.fixed_str;
        for (int i = 0; i <= R; i++)
        {
            swap(curr_in[i], curr_in[0]); // Swaps can always count on beginning
            char first = curr_in[0];
            curr_in.erase(0, 1);
            to_push.in_str = curr_in;
            //             cout<<"in_str is: "<< curr_in<<endl;
            //             cout<<"Also: "<<first + curr_fix<<endl;
            curr_fix = first + curr_fix;
            to_push.fixed_str = curr_fix;
            // cout<<"fixed_str is: "<< to_push.fixed_str<<endl<<endl;
            curr_in = first + curr_in;
            curr_fix.erase(0, 1);
            swap(curr_in[i], curr_in[0]);
            recurStack.push(to_push);
        }
    }
    return final_output;
}

// This recursive function generates all subsequences of the input in_str *appended* to the fixed_str, and outputs them in the list provided as an argument
// Input: string fixed_str, string in_str, pointer to list list_ptr
// Output: void, but list referenced by list_ptr is modified
//
void allSubSeqRec(string in_str, string fixed_str, List *list_ptr)
{
    if (in_str.length() == 0) // base case
    {
        list_ptr->insert(fixed_str); // insert the fixed string into list
        return;
    }
    char top = in_str.back();                        // get the last element of the string
    in_str.pop_back();                               // delete last element of in_str
    allSubSeqRec(in_str, fixed_str, list_ptr);       // recursive call for subsequences without top
    allSubSeqRec(in_str, top + fixed_str, list_ptr); //  recursive call for subsequences with top
    return;
}

// This function generates all subsequences of the input in_str, and outputs them as a list. This is the recursive version
// Input: string in_str
// Output: list of all subsequences of in_str
//
List allSubSeq(string in_str)
{
    List *final_output = new List();        // generate empty list
    allSubSeqRec(in_str, "", final_output); // populate list with output
    return *final_output;
}

int main(int argc, char **argv)
{
    if (argc < 3) // must provide two arguments as input
    {
        throw std::invalid_argument("Usage: ./hello <INPUT FILE> <OUTPUT FILE>"); // throw error
    }

    ifstream input;  // stream for input file
    ofstream output; // stream for output file

    input.open(argv[1]);  // open input file
    output.open(argv[2]); // open output file

    string in_str; // to store the input string from the file

    getline(input, in_str); // get the single string from the input file

    List myList = allSubSeqStack(in_str); // initializing the linked list
    // List myList = allAnagramsStack(in_str); // initializing the linked list
    //     List myList = bubblingStack(in_str);
    // List myList = stretchStack(in_str, 2);
    //     List myList = language(in_str,3);
    // myList.sort(); // sort the list

    output << myList.print("\n") << endl; // print the list, using a new line as delimiter between items of the list

    myList.deleteList(); // free all the memory of this list

    input.close();
    output.close();
}
